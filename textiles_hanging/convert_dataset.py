import os
import logging
import csv

import begin
from tqdm import tqdm
try:
    import OpenEXR
    import Imath
except ImportError:
    logging.error("This program requires OpenEXR. Please install system-wide package (sudo apt install libopenexr-dev) and")
    logging.error("then install Python bindings with pip")
    exit(1)
import numpy as np

exr_filext = '.exr0200.exr'


def get_dataset_filenames(data_folder):
    img_prefix, img_ext = 'img-', exr_filext
    exr_files = [f for f in os.listdir(data_folder) if img_prefix in f and img_ext in f]
    files = [f[:f.find('.')] for f in exr_files]
    csv_files = [f+'.csv' for f in files]
    error = False
    for f in csv_files:
        if f not in os.listdir(data_folder):
            logging.error("File {} not found".format(f))
            error = True
    if error:
        logging.error("Some files are missing. Run the following command to delete them: ")
        logging.error("rm {}".format(" ".join([f[:f.find('.')]+'.*' for f in csv_files
                                               if f not in os.listdir(data_folder)])))
        return None

    logging.debug("{} files found.".format(len(files)))
    logging.debug(files)
    return files


def numpy_from_exr(filepath):
    """
    Loads an EXR image (depth, just one channel) into a Numpy array

    Inspiration: https://gist.github.com/jadarve/de3815874d062f72eaf230a7df41771b
    """
    input = OpenEXR.InputFile(filepath)  # Loop in the final version
    dw = input.header()['dataWindow']
    isize = (dw.max.x - dw.min.x + 1, dw.max.y - dw.min.y + 1)

    imgStr = input.channel('R', Imath.PixelType(Imath.PixelType.FLOAT))
    img = np.fromstring(imgStr, dtype=np.float32)
    img.shape = (isize[1], isize[0])  # Numpy arrays are (row, col)
    return img


@begin.start(auto_convert=True)
@begin.logging
def main(in_folder: 'Input folder containing the dataset'='.', out_folder: 'Output folder for the npz file'='.',
         resize: 'If True, resizes images to 240x180'=False,
         imagenet_size: 'IF True, resizes to 224x224 (and crops)'=False,
         full_trajs: 'If True, generates a file with the full trajectories'=False):
    """
    Converts a dataset generated by blender (EXR images and CSV trajectories) to a numpy npz file containing all
    the data.
    """
    in_folder = os.path.abspath(os.path.expanduser(in_folder))
    out_folder = os.path.abspath(os.path.expanduser(out_folder))
    logging.info("Input folder: {}".format(in_folder))
    logging.info("Output folder: {}".format(out_folder))
    if resize:
        logging.info("Scaling enabled.")
        if imagenet_size:
            logging.info("Using imagenet size (224, 224, 3)")
    else:
        logging.info("Scaling disabled. (Enable with --resize)")
    if full_trajs:
        logging.info("Dumping full trajectories enabled.")
    else:
        logging.info("Dumping full trajectories disabled. (Enable with --full-trajs)")


    file_ids = get_dataset_filenames(in_folder)
    exr_files = [f+exr_filext for f in file_ids]
    csv_files = [f+'.csv' for f in file_ids]
    logging.info("{} files found.".format(len(exr_files)))

    # Reserve memory for all the images to be loaded
    if resize:
        try:
            from skimage.transform import resize as sk_resize
        except ImportError:
            logging.error("Scikit-image cannot be found. Please install it (pip install scikit-image)")
            exit(1)
        if imagenet_size:
            X = np.zeros((len(exr_files), 224, 224, 3))
        else:
            X = np.zeros((len(exr_files), 180, 240))
    else:
        X = np.zeros((len(exr_files), 240, 320))

    Y = np.zeros((len(exr_files), 2, 3))

    if full_trajs:
        logging.warning("Generating full trajectories with 51 as length, which is ok for datasets 6, 7 and later. \
                         Otherwise, use 81 as trajectory length")
        Y_full = np.zeros((len(exr_files), 51, 3))
    else:
        Y_full = None

    # Load images
    for i, (exr_file, csv_file) in tqdm(enumerate(zip(exr_files, csv_files)), total=len(exr_files)):
        # Load exr file
        if resize:
            if imagenet_size:
                X[i, :, :, 0] = sk_resize(numpy_from_exr(os.path.join(in_folder, exr_file)), (224, 299),
                                          anti_aliasing=True, mode='constant')[:, 37:262]
                X[i, :, :, 1] = X[i, :, :, 0]
                X[i, :, :, 2] = X[i, :, :, 0]
            else:
                X[i, :, :] = sk_resize(numpy_from_exr(os.path.join(in_folder, exr_file)), (180, 240),
                                       anti_aliasing=True, mode='constant')
        else:
            X[i, :, :] = numpy_from_exr(os.path.join(in_folder, exr_file))

        # Load csv file
        reader = csv.reader(open(os.path.join(in_folder, csv_file), "r"), delimiter=" ")
        trajectory_data = list(reader)
        trajectory = np.array(trajectory_data).astype("float")
        Y[i, 0, :] = trajectory[4]
        Y[i, 1, :] = trajectory[-1]

        if full_trajs:
            Y_full[i, :, :] = trajectory[:]

    # Save files
    np.savez_compressed(os.path.join(out_folder, 'data{}{}.npz'.format('-resized' if resize and not imagenet_size else '',
                                                                       '-imagenet' if imagenet_size else '')), X=X, Y=Y)
    if full_trajs:
        np.savez_compressed(os.path.join(out_folder, 'full_trajs.npz'), Y=Y_full)
